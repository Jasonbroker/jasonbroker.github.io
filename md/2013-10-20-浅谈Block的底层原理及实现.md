Block是iOS4.0+ 和Mac OS X 10.6+ 引进的对C语言的扩展，用来实现匿名函数的特性。

用维基百科的话来说，Block是Apple为C、C++以及Objective-C添加的特性，使得这些语言可以用类lambda表达式的语法来创建闭包（java中也有类似概念）。代码块block本质上和其他变量类似。不同的是，代码块存储的数据是一个函数体。使用代码块是，你可以像调用其他标准函数一样，传入参数数，并得到返回值。
用Apple文档的话来说，A block is an anonymous inline collection of code, and sometimes also called a "closure".

关于闭包，我觉得阮一峰的一句话解释简洁明了：闭包就是能够读取其它函数内部变量的函数。

这个解释用到block来也很恰当：一个函数里定义了个block，这个block可以访问该函数的内部变量。

比如这个简单的block：

        int (^maxBlock)(int, int) = ^(int x, int y) { return x > y ? x : y; };

调用起来也很简单：

        maxBlock(10，20);

脱字符（^）是块的语法标记。按照我们熟悉的参数语法规约所定义的返回值以及块的主体（也就是可以执行的代码)。
可以看到，代码块的调用和函数调用非常相似。

###为什么要使用block？
https://raw.githubusercontent.com/Jasonbroker/Hello-word/master/Images.xcassets/setting.imageset/setting@2x.png

Block除了能够定义参数列表、返回类型外，还能够获取被定义时的词法范围内的状态（比如局部变量），我们称之为值捕获。

例如：

        int a = 10;

            void (^block)() = ^{
                NSLog(@"a is %d", a);
            };

        a = 20;

        block(); // 10


在这里，我们虽然改变了a的值为20 ，但是由于block是值捕获上文中局部变量a值，所以该代码块生成时，传入block的其实并非变量a，而是其值10；

这点我们可以通过讲oc代码转换成c++代码看出block的内部实现原理；
使用命令行:

        clang -rewrite-objc main.m

可以将main.m 的oc代码转换成.cpp的C++代码；

        int main(int argc, const char * argv[])
        {

            { __AtAutoreleasePool __autoreleasepool;
            int a = 10;

            void (*block)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, **a**);

                a = 20;

                ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);
            }
                return 0;
        }

从block内部的代码中我们可以清楚的看到，传入block的并非是a的地址，而是a也就是说是简单的值传递；

因此输出结果仍然为10；下文对a的值改变不起作用；

那么如果a不是局部变量呢？

       static int a = 10;

        void (^block)() = ^{
        NSLog(@"a is %d", a);
        };

        a = 20;

        block(); // 20

输出结果是 a is 20；

我们再将其转换为C++代码观察main函数变化：

        int main(int argc, const char * argv[])
        {

            /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        static int a = 10;

            void (*block)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, **&a**);

            a = 20;

            ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);
            }

            return 0;
        }

可以看到此时传入block的不再是a而是a的地址了，因此在调用block的时候a值发生改变也就不足为奇了。

实际上，我们在开发中针对想改变block内部值的需求，会在变量前加__block。

这里面已经讲的非常底层了，涉及到一些c++的知识，简单来讲，block的本质是指向c++结构体的指针。

        通常来说，block都是一些简短代码片段的封装，适用作工作单元，通常用来做并发任务、遍历、以及回调。

比如我们可以在遍历NSArray时做一些事情：

- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block;

其中将stop设为YES，就跳出循环，不继续遍历了。

而在很多框架中，block越来越经常被用作回调函数，取代传统的回调方式。

用block作为回调函数，可以使得程序员在写代码更顺畅，不用中途跑到另一个地方写一个回调函数，有时还要考虑这个回调函数放在哪里比较合适。采用block，可以在调用函数时直接写后续处理代码，将其作为参数传递过去，供其任务执行结束时回调。

另一个好处，就是采用block作为回调，可以直接访问局部变量。比如我要在一批用户中修改一个用户的name，修改完成后通过回调更新对应用户的单元格UI。这时候我需要知道对应用户单元格的index，如果采用传统回调方式，要嘛需要将index带过去，回调时再回传过来；要嘛通过外部作用域记录当前操作单元格的index（这限制了一次只能修改一个用户的name）；要嘛遍历找到对应用户。而使用block，则可以直接访问单元格的index。

##block的常见应用


(1)代码用在字符串数组排序

        NSArray *stringArray = [NSArray arrayWithObjects:@"abc 1", @"abc 21", @"abc 12",@"abc 13",@"abc 05",nil];
        NSComparator sortBlock = ^(id string1, id string2)
        {
            return [string1 compare:string2];
        };
        NSArray *sortArray = [stringArray sortedArrayUsingComparator:sortBlock];

        NSLog(@"sortArray:%@", sortArray);

        运行结果：sortArray:(
            "abc 05",
            "abc 1",
            "abc 12",
            "abc 13",
            "abc 21"
        )

(2)代码块的递归调用

    代码块想要递归调用，代码块变量必须是**全局变量**或者是**静态变量**，这样在程序启动的时候代码块变量就初始化了，可以递归调用

        static void (^ const blocks)(int) = ^(int a)
        {
            if (a > 0) {
            NSLog(@"num:%d", a);
            blocks(a - 1);
            }
        };
        blocks(10);

运行打印结果：

    num:3
    num:2
    num:1



##(3) block实现函数回调

block自从引入以来，回调用法被广泛使用于多线程，网络请求等框架。你要是写一个框架不会block回调简直无法直视。因此也特别特别特别给最后一个block加了重点号。

什么是回调呢？简单的讲，就是干完一件事以后，通知你，问你一下还干啥？
这个一听，好像delegate 通知都能实现，为啥还要用block呢？

且看下面的实例分析：

现在有个情景：小明的爸爸让小明去写作业，作业有语文，数学，英语。小明的爸爸是学霸，小明做完作业以后要给他检查作业。

        Son *son = [[Son alloc] init];
        
        Father *father = [[Father alloc] init];
        
        [son writeHomework];
        
        [father checkHomeWork];
        
小明写了三种作业，然后他老爸检查作业。

好了，这个代码看起来是没问题的，儿子写完作业爸爸检查作业，完美。

但是仔细看来问题很大：首先，儿子写完作业鬼知道多久，他写一年难道爸爸创建出来要等儿子一年么？然后，儿子写完作业，爸爸没空怎么办？妈妈不能检查么？隔壁王叔叔不能检查么？代码粘性太大了。

那么怎么解决呢？我们可以用代理嘛。儿子对象创建以后要指定一个代理处理作业


        Son *son = [[Son alloc] init];
        
        Father *father = [[Father alloc] init];
        
        son.delegate = father;
        
        // 儿子要有一个代理属性；
	        
	     [son writeHomework];
	        
儿子要有代理；

			@protocol sonDelegate <NSObject>
			
			- (void)homeworkDidFinished;
			
			@end

还要有代理属性：

			@property (nonatomic, weak)id<sonDelegate> delegate;
			
写完作业以后触发：

		- (void)homeworkDone
		{
		    if ([self.delegate respondsToSelector:@selector(homeworkDidFinished)]) {
        [self.delegate homeworkDidFinished];		    }
		}

        
然后爸爸要成为代理，就要实现代理方法

		- (void)homeworkDidFinished
		{
		    NSLog(@"爸爸检查语文");
		    NSLog(@"爸爸检查数学");
		    NSLog(@"爸爸检查英语");
		}

经过这么多步骤，终于完成了。成功输出了结果但是你没有发现，如此简单的一件事情被这家伙搞这么复杂么？

我们拿通知怎么实现？
		        
		   [[NSNotificationCenter defaultCenter] addObserver:father selector:@selector(checkHomeWork) name:@"homeworkDone" object:nil];
        
        [son writeHomework];
        
        [[NSNotificationCenter defaultCenter] postNotificationName:@"homeworkDone" object:nil userInfo:nil];
        
同样正确输出了结果。看上去貌似也不错，不过也存在一个问题就是不够灵活，如果不是爸爸检查是妈妈检查，观察者就是妈妈了。还是有点麻烦，而且通知的性能也不高。

其实我们的需求很简单，不过是想要当儿子写完作业以后通知某人做某事。我们直接把那个人要做的事情提前安排好，当儿子写完作业以后去做就ok了啊！

提前将完成作业以后的代码保存在finishBlock中：
		
		- (void)writeHomeworkWithFinishHandler:(void (^)(void))finishBlock
		{
		    NSLog(@"小明写语文");
		    NSLog(@"小明写数学");
		    NSLog(@"小明写英语");
		    
		    finishBlock();
		    
		    NSLog(@"作业完成");
		}

那么在main函数中，就非常非常简单了。

		   [son writeHomeworkWithFinishHandler:^{
            [father checkHomeWork];
        }];
        
嗯，完成了。就是这么简单方便。因为block具有代码集中，简单，方便的特点，也是苹果非常推荐使用的。





















