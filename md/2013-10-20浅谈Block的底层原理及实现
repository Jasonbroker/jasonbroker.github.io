Block是iOS4.0+ 和Mac OS X 10.6+ 引进的对C语言的扩展，用来实现匿名函数的特性。

用维基百科的话来说，Block是Apple为C、C++以及Objective-C添加的特性，使得这些语言可以用类lambda表达式的语法来创建闭包（java中也有类似概念）。代码块block本质上和其他变量类似。不同的是，代码块存储的数据是一个函数体。使用代码块是，你可以像调用其他标准函数一样，传入参数数，并得到返回值。
用Apple文档的话来说，A block is an anonymous inline collection of code, and sometimes also called a "closure".

关于闭包，我觉得阮一峰的一句话解释简洁明了：闭包就是能够读取其它函数内部变量的函数。

这个解释用到block来也很恰当：一个函数里定义了个block，这个block可以访问该函数的内部变量。

比如这个简单的block：

        int (^maxBlock)(int, int) = ^(int x, int y) { return x > y ? x : y; };

调用起来也很简单：

        maxBlock(10，20);

脱字符（^）是块的语法标记。按照我们熟悉的参数语法规约所定义的返回值以及块的主体（也就是可以执行的代码)。
可以看到，代码块的调用和函数调用非常相似。

###为什么要使用block？
https://raw.githubusercontent.com/Jasonbroker/Hello-word/master/Images.xcassets/setting.imageset/setting@2x.png

Block除了能够定义参数列表、返回类型外，还能够获取被定义时的词法范围内的状态（比如局部变量），我们称之为值捕获。

例如：

        int a = 10;

            void (^block)() = ^{
                NSLog(@"a is %d", a);
            };

        a = 20;

        block(); // 10


在这里，我们虽然改变了a的值为20 ，但是由于block是值捕获上文中局部变量a值，所以该代码块生成时，传入block的其实并非变量a，而是其值10；

这点我们可以通过讲oc代码转换成c++代码看出block的内部实现原理；
使用命令行:

        clang -rewrite-objc main.m

可以将main.m 的oc代码转换成.cpp的C++代码；

        int main(int argc, const char * argv[])
        {

            { __AtAutoreleasePool __autoreleasepool;
            int a = 10;

            void (*block)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, **a**);

                a = 20;

                ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);
            }
                return 0;
        }

从block内部的代码中我们可以清楚的看到，传入block的并非是a的地址，而是a也就是说是简单的值传递；

因此输出结果仍然为10；下文对a的值改变不起作用；

那么如果a不是局部变量呢？

       static int a = 10;

        void (^block)() = ^{
        NSLog(@"a is %d", a);
        };

        a = 20;

        block(); // 20

输出结果是 a is 20；

我们再将其转换为C++代码观察main函数变化：

        int main(int argc, const char * argv[])
        {

            /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool;
        static int a = 10;

            void (*block)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, **&a**);

            a = 20;

            ((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);
            }

            return 0;
        }

可以看到此时传入block的不再是a而是a的地址了，因此在调用block的时候a值发生改变也就不足为奇了。

实际上，我们在开发中针对想改变block内部值的需求，会在变量前加__block。

这里面已经讲的非常底层了，涉及到一些c++的知识，简单来讲，block的本质是指向c++结构体的指针。

        通常来说，block都是一些简短代码片段的封装，适用作工作单元，通常用来做并发任务、遍历、以及回调。

比如我们可以在遍历NSArray时做一些事情：

- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block;

其中将stop设为YES，就跳出循环，不继续遍历了。

而在很多框架中，block越来越经常被用作回调函数，取代传统的回调方式。

用block作为回调函数，可以使得程序员在写代码更顺畅，不用中途跑到另一个地方写一个回调函数，有时还要考虑这个回调函数放在哪里比较合适。采用block，可以在调用函数时直接写后续处理代码，将其作为参数传递过去，供其任务执行结束时回调。

另一个好处，就是采用block作为回调，可以直接访问局部变量。比如我要在一批用户中修改一个用户的name，修改完成后通过回调更新对应用户的单元格UI。这时候我需要知道对应用户单元格的index，如果采用传统回调方式，要嘛需要将index带过去，回调时再回传过来；要嘛通过外部作用域记录当前操作单元格的index（这限制了一次只能修改一个用户的name）；要嘛遍历找到对应用户。而使用block，则可以直接访问单元格的index。

##block的常见应用


(1)代码用在字符串数组排序

        NSArray *stringArray = [NSArray arrayWithObjects:@"abc 1", @"abc 21", @"abc 12",@"abc 13",@"abc 05",nil];
        NSComparator sortBlock = ^(id string1, id string2)
        {
            return [string1 compare:string2];
        };
        NSArray *sortArray = [stringArray sortedArrayUsingComparator:sortBlock];

        NSLog(@"sortArray:%@", sortArray);

        运行结果：sortArray:(
            "abc 05",
            "abc 1",
            "abc 12",
            "abc 13",
            "abc 21"
        )

(2)代码块的递归调用

    代码块想要递归调用，代码块变量必须是**全局变量**或者是**静态变量**，这样在程序启动的时候代码块变量就初始化了，可以递归调用

        static void (^ const blocks)(int) = ^(int a)
        {
            if (a > 0) {
            NSLog(@"num:%d", a);
            blocks(a - 1);
            }
        };
        blocks(10);

运行打印结果：

    num:3
    num:2
    num:1


(3) block 保存代码



(4) block实现函数回调

block自从引入以来，回调用法被广泛使用于多线程，网络请求等框架。



