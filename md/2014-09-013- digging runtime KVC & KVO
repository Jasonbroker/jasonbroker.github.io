**深入探讨 runtime机制及KVC KVO**

上一篇文章讨论了runtime机制以及很多不错的应用，讲OC 运行时不得不提到的就是传说中的Key-Value Coding (KVC)还有Key-Value Observing (KVO)。


## Key-Value Coding (KVC) 的底层实现

KVC是基于啥的呢？当然是运行时；运行时内部的什么技术呢？

        isa指针

isa就是 is a 或者叫做is a kind of，也就是说“属于”，实际上，isa就是指向其真实类型的指针。每一个OC对象都包含此参数。

isa 奠定了oc消息机制的基础。当接受者收到消息的时候，消息函数先根据isa找到这个类，然后找到这个类的所有实现，也就是说找到了方法列表，然后试图查找要执行的方法，如果找不到就去父类中查找，直到查找到给予objc_msgSend作为参数执行或找不到这个方法则报“未识别的selector”错误。

    KVC就运用了 isa-swizzle 技术来实现查找定位的。

比如，下面的KVC代码：

        [person setValue:@"personName" forKey:@"name"];

会被编译器处理成：
　　
        SEL sel = sel_get_uid("setValue:forKey:");

        IMP method = objc_msg_lookup (person->isa,sel);

        method(person,sel,@"personName",@"name");

其中:

SEL数据类型：它是编译器运行Objective-C里的方法的环境参数。

IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。
　
KVC在调用方法setValue的时候

（1）首先根据方法名找到运行方法的时候所需要的环境参数。

（2）他会从自己isa指针结合环境参数，找到具体的方法实现的接口。

（3）再直接查找得来的具体的方法实现。

##KVO 的底层实现

这样的话前面介绍的KVO实现就好理解了

当一个对象注册了一个观察者, 在运行时该类的isa指针将指向一个中间类，而不是真实的类。

正因为isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。
在调用类的方法的时候，最好要明确对象实例的类名。

这样只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。

        @interface  Person : NSObject
        @property (nonatomic, assign) int age;

在主函数中创建Person 对象并添加监听：

        self.p = [[HMPerson alloc] init];
        // 设置其age为20；
        p.age = 20;
        [self.p addObserver:self forKeyPath:@"age" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];
        p.age = 30;


实现监听方法：

        - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
            {
            NSLog(@"%@对象的%@属性改变了：%@", object, keyPath, change);
            }

    当age的值发生改变的时候， 就会调用监听方法；

    那程序是如何知道值发生改变了呢？

    实际上，当程序在运行时发现我们为p建立监听者的时候，会动态的创建一个继承于Person的类他的名字叫做
`NSKVONotifying_Person`类；
    并重写了`setAge:`方法；

        - （void）setAge:(int)age
        {
            [super setzAge:age];

            // 拿到监听器
        [bserver observeValueForKeyPath:@"age" ofObject:self changeNSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];

        }

那么创建的这个子类和Person类有啥关系呢？这时候就要用到isa指针了。

我们之前讲运行时的时候，讲过一个一模一样的例子。

        p.age = 30

就是发送消息，该方法接收多个参数，给接受者（p），setAge:，年龄30；

        objc_msgSend(p, @selector(setAge:), 30);

该方法首先找到p所属的类，在该类中寻找setAge：；并把30传入。
讲到这里，大家应该已经明白，如果改变p所属的类，那么该重写方法就可以实现了。
没错，在运行的时候，p的类型已经变为了NSKVONotifying_Person。

由于这个操作并没有改变Person类本身，只是为子类（中间类）重写了setter，因此可以神不知鬼不觉的做到KVO监听了。
